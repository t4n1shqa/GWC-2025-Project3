<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Piece of Cake!</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>
    <style>
      body {
        margin: 0;
        height: 100vh;
        display: flex;
        justify-content: center; 
        align-items: center;     
        background: #ffffff;    
      }
      canvas {
        display: block;
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
        border-radius: 12px;
      }
    </style>
  </head>
  <body>
    <script>
      class CakeStack extends Phaser.Scene {
        constructor() {
          super('CakeStack');
        }

        preload() {
          // cake images can be loaded here later
        }

        create() {
          // Game variables
          this.score = 0;
          this.blockHeight = 30;
          this.blockWidth = 200;
          this.baseY = 700;
          this.direction = 1;
          this.speed = 200;
          this.stackedBlocks = [];
          this.isGameOver = false;
          this.cameraOffset = 0;
          
          // Score text
          this.scoreText = this.add.text(400, 40, 'Score: 0', {
            fontSize: '32px',
            fill: '#333',
            fontFamily: 'Arial',
            fontStyle: 'bold'
          }).setOrigin(0.5);
          this.scoreText.setScrollFactor(0);
          
          // Create base block
          const baseBlock = this.add.rectangle(400, this.baseY, this.blockWidth, this.blockHeight, 0xff6b9d);
          baseBlock.setStrokeStyle(2, 0x000000);
          this.stackedBlocks.push({
            x: 400,
            y: this.baseY,
            width: this.blockWidth,
            rect: baseBlock
          });
          
          // Create moving block
          this.createMovingBlock();
          
          // Input handling
          this.input.on('pointerdown', () => this.placeBlock());
          this.input.keyboard.on('keydown-SPACE', () => this.placeBlock());
        }

        createMovingBlock() {
          if (this.isGameOver) return;
          
          const lastBlock = this.stackedBlocks[this.stackedBlocks.length - 1];
          const newY = lastBlock.y - this.blockHeight;
          
          this.movingBlock = this.add.rectangle(0, newY, this.blockWidth, this.blockHeight, 0xff6b9d);
          this.movingBlock.setStrokeStyle(2, 0x000000);
          
          this.direction = Math.random() > 0.5 ? 1 : -1;
          this.movingBlock.x = this.direction === 1 ? 0 : 800;
        }

        update(time, delta) {
          if (this.isGameOver || !this.movingBlock) return;
          
          this.movingBlock.x += this.direction * this.speed * (delta / 1000);
          
          if (this.movingBlock.x >= 800 || this.movingBlock.x <= 0) {
            this.direction *= -1;
          }
        }

        placeBlock() {
          if (this.isGameOver || !this.movingBlock) return;
          
          const lastBlock = this.stackedBlocks[this.stackedBlocks.length - 1];
          const movingX = this.movingBlock.x;
          const movingY = this.movingBlock.y;
          
          const leftEdge = Math.max(movingX - this.blockWidth / 2, lastBlock.x - lastBlock.width / 2);
          const rightEdge = Math.min(movingX + this.blockWidth / 2, lastBlock.x + lastBlock.width / 2);
          const overlapWidth = rightEdge - leftEdge;
          
          if (overlapWidth <= 0) {
            this.createFallingPiece(movingX, movingY, this.blockWidth);
            this.movingBlock.destroy();
            this.movingBlock = null;
            this.gameOver();
            return;
          }
          
          const newCenterX = (leftEdge + rightEdge) / 2;
          
          // Left overhang
          if (movingX - this.blockWidth / 2 < leftEdge) {
            const leftOverhang = leftEdge - (movingX - this.blockWidth / 2);
            const leftPieceX = movingX - this.blockWidth / 2 + leftOverhang / 2;
            this.createFallingPiece(leftPieceX, movingY, leftOverhang);
          }
          
          // Right overhang
          if (movingX + this.blockWidth / 2 > rightEdge) {
            const rightOverhang = (movingX + this.blockWidth / 2) - rightEdge;
            const rightPieceX = movingX + this.blockWidth / 2 - rightOverhang / 2;
            this.createFallingPiece(rightPieceX, movingY, rightOverhang);
          }
          
          // Update moving block to stacked position
          this.movingBlock.x = newCenterX;
          this.movingBlock.displayWidth = overlapWidth;
          
          // Add to stacked blocks
          this.stackedBlocks.push({
            x: newCenterX,
            y: movingY,
            width: overlapWidth,
            rect: this.movingBlock
          });
          
          // Update score
          this.score += 10;
          this.scoreText.setText('Score: ' + this.score);
          
          // Bounce animation
          this.tweens.add({
            targets: this.movingBlock,
            scaleY: 0.8,
            duration: 100,
            yoyo: true,
            ease: 'Quad.easeInOut'
          });
          
          // Update block width for next block
          this.blockWidth = overlapWidth;
          
          // Move tower down if it gets too high (remove bottom block)
          if (movingY < 150) {
            // Remove the bottom block (base)
            if (this.stackedBlocks.length > 1) {
              const bottomBlock = this.stackedBlocks.shift();
              
              // Fade out and destroy bottom block
              this.tweens.add({
                targets: bottomBlock.rect,
                alpha: 0,
                duration: 300,
                onComplete: () => {
                  bottomBlock.rect.destroy();
                }
              });
              
              // Move all remaining blocks down
              for (let block of this.stackedBlocks) {
                this.tweens.add({
                  targets: block.rect,
                  y: block.rect.y + this.blockHeight,
                  duration: 300,
                  ease: 'Quad.easeOut'
                });
                block.y += this.blockHeight;
              }
              
              // Move the moving block down too
              if (this.movingBlock) {
                this.tweens.add({
                  targets: this.movingBlock,
                  y: this.movingBlock.y + this.blockHeight,
                  duration: 300,
                  ease: 'Quad.easeOut'
                });
              }
            }
          }
          
          // Increase difficulty
          this.speed = Math.min(400, this.speed + 5);
          
          this.movingBlock = null;
          
          // Create next block
          this.time.delayedCall(200, () => {
            this.createMovingBlock();
          });
        }
        
        createFallingPiece(x, y, width) {
          const color = this.movingBlock ? this.movingBlock.fillColor : 0xff6b9d;
          const fallingPiece = this.add.rectangle(x, y, width, this.blockHeight, color);
          fallingPiece.setStrokeStyle(2, 0x000000);
          
          // Falling and fading animation
          this.tweens.add({
            targets: fallingPiece,
            y: y + 500,
            alpha: 0,
            angle: Phaser.Math.Between(-180, 180),
            duration: 1000,
            ease: 'Quad.easeIn',
            onComplete: () => {
              fallingPiece.destroy();
            }
          });
        }
              
        gameOver() {
          this.isGameOver = true;
          
          // Game over text
          const gameOverText = this.add.text(400, 300, 'GAME OVER', {
            fontSize: '64px',
            fill: '#ff0000',
            fontFamily: 'Arial',
            fontStyle: 'bold',
            stroke: '#ffffff',
            strokeThickness: 6
          }).setOrigin(0.5);
          gameOverText.setScrollFactor(0);
          
          // Final score
          const finalScore = this.add.text(400, 380, 'Final Score: ' + this.score, {
            fontSize: '32px',
            fill: '#333',
            fontFamily: 'Arial',
            fontStyle: 'bold'
          }).setOrigin(0.5);
          finalScore.setScrollFactor(0);
          
          // Play again button
          const button = this.add.rectangle(400, 480, 200, 60, 0x4CAF50);
          button.setStrokeStyle(3, 0x000000);
          button.setInteractive({ useHandCursor: true });
          button.setScrollFactor(0);
          
          const buttonText = this.add.text(400, 480, 'Play Again', {
            fontSize: '28px',
            fill: '#ffffff',
            fontFamily: 'Arial',
            fontStyle: 'bold'
          }).setOrigin(0.5);
          buttonText.setScrollFactor(0);
          
          // Button hover effect
          button.on('pointerover', () => {
            button.setFillStyle(0x5DBF63);
          });
          
          button.on('pointerout', () => {
            button.setFillStyle(0x4CAF50);
          });
          
          button.on('pointerdown', () => {
            this.scene.restart();
          });
        }
      }

      const config = {
        type: Phaser.AUTO,
        width: 800,
        height: 800,
        backgroundColor: '#d9ffff',
        scene: CakeStack,
      };

      new Phaser.Game(config);
    </script>
  </body>
</html>